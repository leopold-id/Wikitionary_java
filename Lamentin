package projetFinal;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

// sa prononciation;
// ses catégories morpho-syntaxiques;
// ses traductions;
// ses synonymes;
// ses antonymes.

public class Lamentin implements Serializable {

	String prononciations;
	ArrayList<String> categories_morphosyntaxiques;
	HashMap<String, HashMap<String, String>> traductions;
	ArrayList<String> synonymes;
	ArrayList<String> antonymes;

	public Lamentin(String content) {
		this.prononciations = init_prononciation(content);
		this.categories_morphosyntaxiques = init_categories_morphosyntaxiques(content);
		// this.traductions = init_traductions(content);
		this.synonymes = init_synonymes(content);
		this.antonymes = init_antonymes(content);
	}

	// prononciation
	public String init_prononciation(String content) {
		String prononciation = new String();

		Pattern p = Pattern.compile("\\{\\{pron\\|(.+?)\\|.+?\\}\\}");
		Matcher m = p.matcher(content);

		if (m.find()) {
			prononciation = m.group(1);

		}
		return prononciation;
	}

	// categories morpho-syntaxiques
	public ArrayList<String> init_categories_morphosyntaxiques(String content) {

		ArrayList<String> list_categories = new ArrayList<>();

		Pattern p = Pattern.compile("====? \\{\\{S\\|.*?\\|fr\\}\\} ====?");
		Matcher m = p.matcher(content);

		while (m.find()) {
			list_categories.add(m.group(0).split("\\|")[1]);
		}

		return list_categories;
	}

	// traductions
	public HashMap<String, HashMap<String, String>> init_traductions(String content) {

		HashMap<String, HashMap<String, String>> map_sens_map_langue_traductions = new HashMap<>();

		String[] bloc = content.split("\\{\\{S\\|traductions\\}\\} ====?");

		if (bloc.length > 1) {

			String traductions = bloc[1].split("===?")[0];

			String[] blocSens = traductions.split("\\{\\{trad-fin\\}\\}");

			for (String section : blocSens) {
				HashMap<String, String> map_langue_traductions = new HashMap<>();
				String sensDefinition = new String();

				Pattern pSens = Pattern.compile("\\{\\{trad-début\\|.+?\\}\\}");
				Matcher mSens = pSens.matcher(section);

				// il y a un sens spécifique pour la traduction
				if (mSens.find()) {

					// on récupère le sens pour le stocker comme clé dans le grand dico
					sensDefinition = mSens.group(0).split("\\|")[1];

					// on coupe après ce sens et on récupère ce qu'il y a après (les trad dans
					// toutes les langues)
					String filtre = section.split("\\{\\{trad-début\\|.+?\\}\\}")[1];

					// on sépare chaque ligne de langue différente
					String[] listeLignes = filtre.split("\\*");

					// pour jarter les putains de lignes vides
					if (listeLignes.length > 1) {

						// on boucle sur toutes les langues
						for (String langue : listeLignes) {

							String[] nomLangueDef = langue.split(":");

							// jarter les lignes vides
							if (nomLangueDef.length > 1) {

								// System.out.println(nomLangueDef[1]);
								// System.out.println("------");
								// System.out.println(nomLangueDef[0]);
								// System.out.println(nomLangueDef[1]);

								map_langue_traductions.put(nomLangueDef[0], nomLangueDef[1]);

							}
						}
					}
				}

				map_sens_map_langue_traductions.put(sensDefinition, map_langue_traductions);

			}

		}

		return map_sens_map_langue_traductions;

	}

	// synonymes
	public ArrayList<String> init_synonymes(String content) {

		ArrayList<String> list_synonymes = new ArrayList<>();

		String[] bloc = content.split("\\{\\{S\\|synonymes\\}\\} ====?");
		if (bloc.length > 1) {
			String synonymes = bloc[1].split("===")[0];

			Pattern p = Pattern.compile("\\* \\[\\[(.+?)\\]\\]");
			Matcher m = p.matcher(synonymes);

			while (m.find()) {
				list_synonymes.add(m.group(1));
			}

		}
		return list_synonymes;
	}

	// antonymes
	public ArrayList<String> init_antonymes(String content) {
		ArrayList<String> list_antonymes = new ArrayList<>();

		String[] bloc = content.split("\\{\\{S\\|antonymes\\}\\} ====?");
		if (bloc.length > 1) {
			String antonymes = bloc[1].split("===")[0];

			Pattern p = Pattern.compile("\\* \\[\\[(.+?)\\]\\]");
			Matcher m = p.matcher(antonymes);

			while (m.find()) {
				list_antonymes.add(m.group(1));
			}

		}
		return list_antonymes;
	}

	public String get_prononciation() {
		return this.prononciations;
	}

	public ArrayList<String> get_pos() {
		return this.categories_morphosyntaxiques;
	}

	public HashMap<String, HashMap<String, String>> get_traductions() {
		return this.traductions;
	}

	public ArrayList<String> get_synonymes() {
		return this.synonymes;
	}

	public ArrayList<String> get_antonymes() {
		return this.antonymes;
	}

	public String select(String requete) {

		if (requete.equals("pro")) {
			return this.prononciations.toString();
		} else if (requete.equals("pos")) {
			return this.categories_morphosyntaxiques.toString();
		} else if (requete.equals("trad")) {
			return this.traductions.toString();
		} else if (requete.equals("syn")) {
			return this.synonymes.toString();
		} else if (requete.equals("ant")) {
			return this.antonymes.toString();
		} else {
			return "requete inconnue";
		}
	}

	public String introspection() {
		return String.format(
				"prononciations : %s, catégories morphosyntaxique : %s, traduction : %s, synonymes : %s, antonymes : %s",
				prononciations, categories_morphosyntaxiques, traductions, synonymes, antonymes);
	}
}
